---
phase: 10-claims-engine
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - packages/server/src/services/reward-transfer.ts
  - packages/server/src/routes/rewards.ts
  - packages/server/src/db/reward-claims.ts
autonomous: true
user_setup:
  - service: "Rewards Wallet"
    why: "SPL token transfers require a funded wallet"
    env_vars:
      - name: REWARDS_WALLET_PRIVATE_KEY
        source: "Base58 encoded private key of wallet holding $OPEN tokens"
      - name: OPEN_TOKEN_MINT
        source: "$OPEN SPL token mint address on Solana mainnet"
      - name: SOLANA_RPC_URL
        source: "Solana RPC endpoint (e.g., Helius, QuickNode)"

must_haves:
  truths:
    - "System executes SPL token transfer when user confirms claim"
    - "Claim status updates to 'completed' with tx_signature on success"
    - "Claim status updates to 'failed' on transfer error"
    - "Insufficient funds returns clear error, claim stays 'pending' for retry"
  artifacts:
    - path: "packages/server/src/services/reward-transfer.ts"
      provides: "SPL token transfer execution"
      exports: ["executeRewardTransfer"]
    - path: "packages/server/src/routes/rewards.ts"
      provides: "Execute claim endpoint"
      contains: "POST /claims/:id/execute"
  key_links:
    - from: "packages/server/src/routes/rewards.ts"
      to: "packages/server/src/services/reward-transfer.ts"
      via: "executeRewardTransfer call"
      pattern: "executeRewardTransfer"
    - from: "packages/server/src/services/reward-transfer.ts"
      to: "@solana/spl-token"
      via: "SPL token transfer"
      pattern: "createTransferInstruction"
---

<objective>
Implement the actual SPL token transfer from rewards wallet to user's claim wallet. When user confirms a claim (status='processing'), execute the $OPEN token transfer on Solana, update claim status to 'completed' with transaction signature, or 'failed' if transfer fails.

Purpose: Core claim fulfillment - actually send tokens to users.
Output: Token transfer service and execution endpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-claims-engine/10-CONTEXT.md
@.planning/phases/10-claims-engine/10-RESEARCH.md

# Existing SPL transfer pattern
@packages/server/src/services/claims.ts (lines 277-378 - executeGaslessSolanaTransfer)

# Phase 10-01 outputs (reference after completion)
# @.planning/phases/10-claims-engine/10-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reward transfer service for SPL token transfers</name>
  <files>
    packages/server/src/services/reward-transfer.ts
  </files>
  <action>
Create `packages/server/src/services/reward-transfer.ts` following the pattern in `services/claims.ts` (executeGaslessSolanaTransfer):

```typescript
/**
 * Execute SPL token transfer from rewards wallet to recipient
 * Rewards wallet pays for transaction fees (no facilitator involved)
 */
export async function executeRewardTransfer(params: {
  recipientAddress: string;  // User's claim wallet
  amount: string;            // Atomic units (9 decimals for $OPEN)
}): Promise<{
  success: boolean;
  signature?: string;
  error?: string;
}> {
  // 1. Load env vars:
  //    - REWARDS_WALLET_PRIVATE_KEY (base58 encoded)
  //    - OPEN_TOKEN_MINT
  //    - SOLANA_RPC_URL (default to mainnet)

  // 2. Validate env vars exist, return error if missing

  // 3. Create connection, keypairs
  //    const connection = new Connection(rpcUrl, 'confirmed');
  //    const rewardsKeypair = Keypair.fromSecretKey(bs58.decode(privateKey));
  //    const recipientPubkey = new PublicKey(recipientAddress);
  //    const mintPubkey = new PublicKey(tokenMint);

  // 4. Get Associated Token Accounts (ATAs)
  //    const senderAta = await getAssociatedTokenAddress(mintPubkey, rewardsKeypair.publicKey);
  //    const recipientAta = await getAssociatedTokenAddress(mintPubkey, recipientPubkey);

  // 5. Build transaction:
  //    - Check if recipient ATA exists, create if not (rewards wallet pays)
  //    - Add transfer instruction

  // 6. Sign and send:
  //    - Get latest blockhash
  //    - Set feePayer to rewards wallet
  //    - Sign with rewards keypair
  //    - Send and confirm

  // 7. Return result with signature or error
}
```

Key differences from executeGaslessSolanaTransfer:
- No facilitator involvement - rewards wallet is both token holder AND fee payer
- Uses $OPEN token mint (9 decimals) not USDC (6 decimals)
- Single signer (rewards wallet) not two signers

Error handling:
- Catch insufficient SOL for fees: "Rewards wallet needs SOL for transaction fees"
- Catch insufficient token balance: "Rewards wallet has insufficient $OPEN balance"
- Log all errors with [RewardTransfer] prefix
  </action>
  <verify>
    TypeScript compiles: `pnpm -F @openfacilitator/server exec tsc --noEmit`
  </verify>
  <done>
    Service exports executeRewardTransfer function.
    Handles env var validation, ATA creation, transfer execution.
    Returns structured success/error response.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add claim execution endpoint that triggers transfer</name>
  <files>
    packages/server/src/routes/rewards.ts
    packages/server/src/db/reward-claims.ts
  </files>
  <action>
1. Add execution endpoint to `packages/server/src/routes/rewards.ts`:

```typescript
/**
 * POST /claims/:id/execute
 * Execute the SPL token transfer for a processing claim
 * Called after user confirms claim in ClaimModal
 */
router.post('/claims/:id/execute', requireAuth, async (req, res) => {
  const userId = req.user!.id;
  const claimId = req.params.id;

  // 1. Get claim, verify ownership
  const claim = getRewardClaimById(claimId);
  if (!claim) return res.status(404).json({ error: 'Claim not found' });
  if (claim.user_id !== userId) return res.status(403).json({ error: 'Forbidden' });

  // 2. Verify claim status is 'processing' (set by initiateClaim)
  if (claim.status !== 'processing') {
    return res.status(400).json({
      error: 'Invalid claim status',
      message: `Claim status is '${claim.status}', must be 'processing'`,
    });
  }

  // 3. Verify claim_wallet is set
  if (!claim.claim_wallet) {
    return res.status(400).json({
      error: 'No claim wallet',
      message: 'Claim wallet must be set before executing',
    });
  }

  // 4. Execute transfer
  const result = await executeRewardTransfer({
    recipientAddress: claim.claim_wallet,
    amount: claim.final_reward_amount,
  });

  // 5. Update claim based on result
  if (result.success) {
    updateRewardClaim(claimId, {
      status: 'completed',
      tx_signature: result.signature!,
      claimed_at: new Date().toISOString(),
    });

    return res.json({
      success: true,
      tx_signature: result.signature,
    });
  } else {
    // On error, set status back to 'pending' so user can retry
    // unless it's a permanent error
    const isPermanent = result.error?.includes('insufficient') ||
                       result.error?.includes('invalid');

    if (!isPermanent) {
      updateRewardClaim(claimId, { status: 'pending' });
    } else {
      updateRewardClaim(claimId, { status: 'failed' });
    }

    return res.status(500).json({
      success: false,
      error: result.error || 'Transfer failed',
      retryable: !isPermanent,
    });
  }
});
```

2. Update the existing `initiateClaim` endpoint (POST /claims/:id/initiate) to also call execute:
   - After setting status to 'processing' and claim_wallet
   - Immediately call executeRewardTransfer
   - This combines initiate + execute into one atomic operation
   - User doesn't need to make two API calls

The combined flow becomes:
1. User clicks "Confirm Claim" in ClaimModal
2. Frontend calls POST /claims/:id/initiate with claim_wallet
3. Backend: validates, sets status='processing', executes transfer, sets status='completed'
4. Returns tx_signature to frontend
  </action>
  <verify>
    Test claim execution (requires env vars set up):
    ```bash
    # Create a test claim in 'processing' status first
    curl -X POST http://localhost:5002/api/rewards/claims/{claimId}/initiate \
      -H "Cookie: better-auth.session_token=..." \
      -H "Content-Type: application/json" \
      -d '{"claim_wallet": "SomeValidSolanaAddress..."}'
    ```
    Should return tx_signature on success or error message on failure.
  </verify>
  <done>
    initiateClaim endpoint executes transfer immediately after setting claim_wallet.
    Returns tx_signature on success.
    Handles errors gracefully (retryable vs permanent).
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles in packages/server
2. With env vars configured:
   - initiateClaim endpoint executes transfer and returns tx_signature
   - Claim status updates to 'completed' with signature
   - Transaction visible on Solscan
3. Without env vars:
   - Clear error message about missing configuration
4. With insufficient balance:
   - Clear error message, claim stays 'pending' for retry
</verification>

<success_criteria>
- SPL token transfer executes successfully when user confirms claim
- Transaction signature stored on claim record
- Claim status correctly reflects completed/failed state
- Error handling provides clear feedback
</success_criteria>

<output>
After completion, create `.planning/phases/10-claims-engine/10-02-SUMMARY.md`
</output>
