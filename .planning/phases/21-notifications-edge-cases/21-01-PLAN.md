---
phase: 21-notifications-edge-cases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/notifications.ts
  - packages/server/src/db/index.ts
  - packages/server/src/routes/notifications.ts
  - packages/server/src/index.ts
  - packages/server/src/services/subscription-billing.ts
  - packages/server/src/routes/subscriptions.ts
autonomous: true

must_haves:
  truths:
    - "Notifications table exists in database"
    - "Notifications can be created, fetched, and dismissed via API"
    - "Payment events generate notifications automatically"
    - "Low balance warnings are created during billing"
    - "Expiration reminders are created 3 days before expiry"
  artifacts:
    - path: "packages/server/src/db/notifications.ts"
      provides: "Notification CRUD operations"
      exports: ["createNotification", "getNotificationsForUser", "getUnreadCount", "markNotificationAsRead", "dismissNotification", "markAllNotificationsAsRead"]
    - path: "packages/server/src/routes/notifications.ts"
      provides: "Notification API endpoints"
      exports: ["notificationsRouter"]
  key_links:
    - from: "packages/server/src/services/subscription-billing.ts"
      to: "packages/server/src/db/notifications.ts"
      via: "createNotification calls"
      pattern: "createNotification\\("
    - from: "packages/server/src/routes/notifications.ts"
      to: "packages/server/src/db/notifications.ts"
      via: "database operations"
      pattern: "getNotificationsForUser|dismissNotification"
---

<objective>
Create the backend infrastructure for the notification system including database schema, CRUD operations, API endpoints, and integration with the subscription billing service.

Purpose: Enable persistent notifications for payment events, low balance warnings, and subscription reminders that users can view and dismiss.

Output: Fully functional notification backend with database storage and API access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-notifications-edge-cases/21-CONTEXT.md
@.planning/phases/21-notifications-edge-cases/21-RESEARCH.md
@packages/server/src/db/index.ts
@packages/server/src/db/subscription-payments.ts
@packages/server/src/services/subscription-billing.ts
@packages/server/src/routes/subscriptions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notifications database layer</name>
  <files>
    packages/server/src/db/notifications.ts
    packages/server/src/db/index.ts
  </files>
  <action>
Create `packages/server/src/db/notifications.ts` with:

1. Define NotificationType enum:
   - 'payment_success'
   - 'payment_failed'
   - 'low_balance'
   - 'expiration_reminder'
   - 'subscription_restored'
   - 'subscription_expired'

2. Define NotificationSeverity enum:
   - 'success' (green)
   - 'warning' (amber)
   - 'error' (red)
   - 'info' (neutral)

3. Define Notification interface:
   - id: string (UUID)
   - user_id: string
   - type: NotificationType
   - title: string
   - message: string
   - severity: NotificationSeverity
   - read: boolean (stored as INTEGER 0/1 in SQLite)
   - dismissed: boolean (stored as INTEGER 0/1)
   - metadata: string (JSON stringified object)
   - created_at: string

4. Implement CRUD functions:
   - `createNotification(userId, type, title, message, severity, metadata?)` - creates notification, returns Notification
   - `getNotificationsForUser(userId, limit?, includesDismissed?)` - returns Notification[], default excludes dismissed, ordered by created_at DESC
   - `getUnreadCount(userId)` - returns number of unread, undismissed notifications
   - `markNotificationAsRead(id, userId)` - marks as read (verifies ownership)
   - `dismissNotification(id, userId)` - marks as dismissed (verifies ownership)
   - `markAllNotificationsAsRead(userId)` - marks all as read for user
   - `hasRecentNotificationOfType(userId, type, hoursAgo)` - checks for duplicate prevention (returns boolean)

5. Add notifications table creation to `packages/server/src/db/index.ts`:
   - Add CREATE TABLE statement after subscription_payments table
   - Add proper indexes (user_id, read, dismissed, created_at)
   - Add export for notifications.ts

Schema:
```sql
CREATE TABLE IF NOT EXISTS notifications (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN (
    'payment_success', 'payment_failed', 'low_balance',
    'expiration_reminder', 'subscription_restored', 'subscription_expired'
  )),
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  severity TEXT NOT NULL CHECK (severity IN ('success', 'warning', 'error', 'info')),
  read INTEGER NOT NULL DEFAULT 0,
  dismissed INTEGER NOT NULL DEFAULT 0,
  metadata TEXT NOT NULL DEFAULT '{}',
  created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user_unread ON notifications(user_id, read, dismissed);
CREATE INDEX IF NOT EXISTS idx_notifications_created ON notifications(created_at);
```

Follow existing patterns from subscription-payments.ts for row type conversion (INTEGER to boolean).
  </action>
  <verify>
Run `npm run build` in packages/server to verify TypeScript compiles.
  </verify>
  <done>
Notifications table exists in database, CRUD functions exported and importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notifications API routes</name>
  <files>
    packages/server/src/routes/notifications.ts
    packages/server/src/index.ts
  </files>
  <action>
Create `packages/server/src/routes/notifications.ts`:

1. Import dependencies:
   - express Router
   - requireAuth middleware from '../middleware/auth.js'
   - All CRUD functions from '../db/notifications.js'

2. Create endpoints:
   ```typescript
   // GET /api/notifications
   // Returns { notifications: Notification[], unreadCount: number }
   router.get('/', requireAuth, async (req, res) => {
     const userId = req.user!.id;
     const notifications = getNotificationsForUser(userId);
     const unreadCount = getUnreadCount(userId);
     res.json({ notifications, unreadCount });
   });

   // POST /api/notifications/:id/read
   // Marks single notification as read
   router.post('/:id/read', requireAuth, async (req, res) => {
     const { id } = req.params;
     const userId = req.user!.id;
     markNotificationAsRead(id, userId);
     res.json({ success: true });
   });

   // POST /api/notifications/:id/dismiss
   // Marks single notification as dismissed (removes from list)
   router.post('/:id/dismiss', requireAuth, async (req, res) => {
     const { id } = req.params;
     const userId = req.user!.id;
     dismissNotification(id, userId);
     res.json({ success: true });
   });

   // POST /api/notifications/mark-all-read
   // Marks all notifications as read for user
   router.post('/mark-all-read', requireAuth, async (req, res) => {
     const userId = req.user!.id;
     markAllNotificationsAsRead(userId);
     res.json({ success: true });
   });
   ```

3. Export router as `notificationsRouter`

4. Register in `packages/server/src/index.ts`:
   - Import: `import { notificationsRouter } from './routes/notifications.js';`
   - Mount: `app.use('/api/notifications', notificationsRouter);`
   - Place after subscriptions router mount

Follow existing route patterns from routes/subscriptions.ts.
  </action>
  <verify>
Start server with `npm run dev` in packages/server and test:
- `curl http://localhost:5002/api/notifications` (should return 401 without auth)
  </verify>
  <done>
Notifications API endpoints accessible and returning proper responses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate notifications into billing service</name>
  <files>
    packages/server/src/services/subscription-billing.ts
    packages/server/src/routes/subscriptions.ts
  </files>
  <action>
Modify `packages/server/src/services/subscription-billing.ts`:

1. Import notification functions:
   ```typescript
   import {
     createNotification,
     hasRecentNotificationOfType,
   } from '../db/notifications.js';
   ```

2. In `processSubscriptionPayment`, after successful payment (where `createSubscriptionPayment` is called with 'success'):
   ```typescript
   // Create payment success notification
   createNotification(
     userId,
     'payment_success',
     'Payment Successful',
     `Your $5 subscription payment was processed successfully.`,
     'success',
     { txHash: paymentResult.txHash, chain, amount }
   );
   ```

3. After failed payment (where both chains fail), after logging the failure:
   ```typescript
   // Create payment failed notification
   createNotification(
     userId,
     'payment_failed',
     'Payment Failed',
     'Subscription payment failed due to insufficient funds on both chains. Please fund your wallet.',
     'error',
     { chain: preferredChain }
   );
   ```

4. After any payment attempt (success or failure), check for low balance and create warning:
   ```typescript
   // Check balance after payment for low balance warning
   const preferredWallet = wallets.find(w => w.network === preferredChain);
   if (preferredWallet) {
     const balanceResult = preferredChain === 'solana'
       ? await getUSDCBalance(preferredWallet.address)
       : await getBaseUSDCBalance(preferredWallet.address);

     const subscriptionCost = SUBSCRIPTION_PRICING.starter;
     const lowBalanceThreshold = subscriptionCost * 2; // 2x = $10

     if (balanceResult.balance < BigInt(lowBalanceThreshold)) {
       // Only create if no recent low_balance notification in last 24h
       if (!hasRecentNotificationOfType(userId, 'low_balance', 24)) {
         createNotification(
           userId,
           'low_balance',
           'Low Balance Warning',
           `Your ${preferredChain} wallet balance is below $10. Consider funding to avoid payment failures.`,
           'warning',
           { chain: preferredChain, balance: balanceResult.formatted }
         );
       }
     }
   }
   ```

Modify `packages/server/src/routes/subscriptions.ts`:

1. Import notification functions:
   ```typescript
   import {
     createNotification,
     hasRecentNotificationOfType,
   } from '../db/notifications.js';
   import { getSubscriptionsExpiringInDays } from '../db/subscriptions.js';
   ```

2. Add `getSubscriptionsExpiringInDays` to subscriptions.ts db file if not exists:
   - Query subscriptions where expires_at is within N days from now
   - Returns array of subscriptions

3. In the `/billing` cron endpoint, BEFORE processing due subscriptions, add expiration reminder check:
   ```typescript
   // Send 3-day expiration reminders
   const expiringIn3Days = getSubscriptionsExpiringInDays(3);
   for (const sub of expiringIn3Days) {
     // Skip if already in grace period
     if (!isInGracePeriod(sub.user_id)) {
       // Only create if no recent expiration_reminder
       if (!hasRecentNotificationOfType(sub.user_id, 'expiration_reminder', 72)) {
         createNotification(
           sub.user_id,
           'expiration_reminder',
           'Subscription Expiring Soon',
           'Your subscription will expire in 3 days. Ensure your wallet is funded to avoid interruption.',
           'warning',
           { expiresAt: sub.expires_at }
         );
       }
     }
   }
   ```

4. In the `/reactivate` endpoint, after successful reactivation, add restored notification:
   ```typescript
   createNotification(
     userId,
     'subscription_restored',
     'Subscription Restored',
     'Your subscription has been successfully reactivated!',
     'success',
     { tier: subscription?.tier, expires: subscription?.expires_at }
   );
   ```

Add `getSubscriptionsExpiringInDays` to `packages/server/src/db/subscriptions.ts`:
```typescript
export function getSubscriptionsExpiringInDays(days: number): Subscription[] {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT * FROM subscriptions
    WHERE date(expires_at) = date('now', '+' || ? || ' days')
  `);
  return stmt.all(days) as Subscription[];
}
```
  </action>
  <verify>
Run `npm run build` in packages/server. All TypeScript should compile.
Test billing cron manually by creating a test subscription expiring in 3 days.
  </verify>
  <done>
Payment success, failure, low balance, expiration reminder, and restoration notifications are automatically created at appropriate trigger points.
  </done>
</task>

</tasks>

<verification>
1. Database: Notifications table exists with proper schema
2. API: All endpoints return expected responses
3. Integration: Payment events create notifications in database
4. No TypeScript errors in build
</verification>

<success_criteria>
- Notifications table created with proper indexes
- CRUD operations work correctly
- API endpoints accessible and functional
- Payment success creates notification
- Payment failure creates notification
- Low balance warning created when balance < $10
- Expiration reminder created 3 days before expiry
- Subscription restored creates notification
- Duplicate notifications prevented (24-hour window for low_balance, 72-hour for expiration_reminder)
</success_criteria>

<output>
After completion, create `.planning/phases/21-notifications-edge-cases/21-01-SUMMARY.md`
</output>
