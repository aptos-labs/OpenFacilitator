---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/server/src/db/index.ts
  - packages/server/src/db/types.ts
  - packages/server/src/db/reward-addresses.ts
  - packages/server/src/db/campaigns.ts
  - packages/server/src/db/reward-claims.ts
  - packages/server/src/db/volume-snapshots.ts
autonomous: true

must_haves:
  truths:
    - "Rewards-related tables exist in SQLite database"
    - "Schema supports all data relationships (user -> addresses, user -> claims, campaign -> claims)"
    - "Database initialization runs without errors"
    - "CRUD operations work for all four tables"
  artifacts:
    - path: "packages/server/src/db/index.ts"
      provides: "CREATE TABLE statements for reward_addresses, campaigns, reward_claims, volume_snapshots"
      contains: "CREATE TABLE IF NOT EXISTS reward_addresses"
    - path: "packages/server/src/db/types.ts"
      provides: "TypeScript interfaces for all reward records"
      contains: "RewardAddressRecord"
    - path: "packages/server/src/db/reward-addresses.ts"
      provides: "CRUD operations for reward addresses"
      exports: ["createRewardAddress", "getRewardAddressById"]
    - path: "packages/server/src/db/campaigns.ts"
      provides: "CRUD operations for campaigns"
      exports: ["createCampaign", "getCampaignById"]
    - path: "packages/server/src/db/reward-claims.ts"
      provides: "CRUD operations for reward claims"
      exports: ["createRewardClaim", "getRewardClaimById"]
    - path: "packages/server/src/db/volume-snapshots.ts"
      provides: "CRUD operations for volume snapshots"
      exports: ["createVolumeSnapshot", "getVolumeSnapshotById"]
  key_links:
    - from: "packages/server/src/db/reward-addresses.ts"
      to: "packages/server/src/db/types.ts"
      via: "import type { RewardAddressRecord }"
      pattern: "import.*RewardAddressRecord.*from.*types"
    - from: "packages/server/src/db/index.ts"
      to: "packages/server/src/db/reward-addresses.ts"
      via: "export * from"
      pattern: "export \\* from './reward-addresses"
---

<objective>
Create the database schema and CRUD modules for the rewards program.

Purpose: Establish the data layer that all subsequent phases build upon. This includes tables for tracking user pay-to addresses, reward campaigns, claim history, and volume snapshots.

Output: Four new tables in SQLite, corresponding TypeScript interfaces, and CRUD modules following existing codebase patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-database-foundation/01-RESEARCH.md
@.planning/phases/01-database-foundation/01-CONTEXT.md

# Codebase patterns to follow exactly
@packages/server/src/db/index.ts
@packages/server/src/db/types.ts
@packages/server/src/db/facilitators.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add reward tables and type definitions</name>
  <files>
    packages/server/src/db/index.ts
    packages/server/src/db/types.ts
  </files>
  <action>
Add four new tables to the `initializeDatabase()` function in index.ts, following the existing CREATE TABLE IF NOT EXISTS pattern. Insert the new table definitions after the existing tables (before the closing backtick of db.exec).

**Tables to add:**

1. **reward_addresses** - User pay-to addresses for volume tracking
```sql
-- Reward addresses table (user pay-to addresses for volume tracking)
CREATE TABLE IF NOT EXISTS reward_addresses (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  chain_type TEXT NOT NULL CHECK (chain_type IN ('solana', 'evm')),
  address TEXT NOT NULL,
  verification_status TEXT NOT NULL DEFAULT 'pending' CHECK (verification_status IN ('pending', 'verified')),
  verified_at TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(user_id, address)
);

CREATE INDEX IF NOT EXISTS idx_reward_addresses_user ON reward_addresses(user_id);
CREATE INDEX IF NOT EXISTS idx_reward_addresses_address ON reward_addresses(address);
CREATE INDEX IF NOT EXISTS idx_reward_addresses_chain ON reward_addresses(chain_type);
```

2. **campaigns** - Reward campaign configuration
```sql
-- Campaigns table (reward campaign configuration)
CREATE TABLE IF NOT EXISTS campaigns (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  pool_amount TEXT NOT NULL,
  threshold_amount TEXT NOT NULL,
  multiplier_facilitator REAL NOT NULL DEFAULT 2.0,
  starts_at TEXT NOT NULL,
  ends_at TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'active', 'ended')),
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_campaigns_status ON campaigns(status);
CREATE INDEX IF NOT EXISTS idx_campaigns_dates ON campaigns(starts_at, ends_at);
```

3. **reward_claims** - User claims against campaigns
```sql
-- Reward claims table (user claims against campaigns)
CREATE TABLE IF NOT EXISTS reward_claims (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES "user" ("id") ON DELETE CASCADE,
  campaign_id TEXT NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
  volume_amount TEXT NOT NULL,
  base_reward_amount TEXT NOT NULL,
  multiplier REAL NOT NULL DEFAULT 1.0,
  final_reward_amount TEXT NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  claim_wallet TEXT,
  tx_signature TEXT,
  claimed_at TEXT,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(user_id, campaign_id)
);

CREATE INDEX IF NOT EXISTS idx_reward_claims_user ON reward_claims(user_id);
CREATE INDEX IF NOT EXISTS idx_reward_claims_campaign ON reward_claims(campaign_id);
CREATE INDEX IF NOT EXISTS idx_reward_claims_status ON reward_claims(status);
```

4. **volume_snapshots** - Daily volume aggregations per address
```sql
-- Volume snapshots table (daily aggregated volume per address)
CREATE TABLE IF NOT EXISTS volume_snapshots (
  id TEXT PRIMARY KEY,
  reward_address_id TEXT NOT NULL REFERENCES reward_addresses(id) ON DELETE CASCADE,
  campaign_id TEXT NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,
  snapshot_date TEXT NOT NULL,
  volume TEXT NOT NULL,
  unique_payers INTEGER NOT NULL DEFAULT 0,
  created_at TEXT NOT NULL DEFAULT (datetime('now')),
  UNIQUE(reward_address_id, campaign_id, snapshot_date)
);

CREATE INDEX IF NOT EXISTS idx_volume_snapshots_address ON volume_snapshots(reward_address_id);
CREATE INDEX IF NOT EXISTS idx_volume_snapshots_campaign ON volume_snapshots(campaign_id);
CREATE INDEX IF NOT EXISTS idx_volume_snapshots_date ON volume_snapshots(snapshot_date);
```

**Then add TypeScript interfaces to types.ts** (add at the end of the file):

```typescript
/**
 * Reward address database record
 * Pay-to addresses tracked for volume rewards
 */
export interface RewardAddressRecord {
  id: string;
  user_id: string;
  chain_type: 'solana' | 'evm';
  address: string;
  verification_status: 'pending' | 'verified';
  verified_at: string | null;
  created_at: string;
}

/**
 * Campaign database record
 * Reward campaign configuration
 */
export interface CampaignRecord {
  id: string;
  name: string;
  pool_amount: string;
  threshold_amount: string;
  multiplier_facilitator: number;
  starts_at: string;
  ends_at: string;
  status: 'draft' | 'active' | 'ended';
  created_at: string;
  updated_at: string;
}

/**
 * Reward claim database record
 * Tracks user claims against campaigns
 */
export interface RewardClaimRecord {
  id: string;
  user_id: string;
  campaign_id: string;
  volume_amount: string;
  base_reward_amount: string;
  multiplier: number;
  final_reward_amount: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  claim_wallet: string | null;
  tx_signature: string | null;
  claimed_at: string | null;
  created_at: string;
}

/**
 * Volume snapshot database record
 * Daily aggregated volume per reward address per campaign
 */
export interface VolumeSnapshotRecord {
  id: string;
  reward_address_id: string;
  campaign_id: string;
  snapshot_date: string;
  volume: string;
  unique_payers: number;
  created_at: string;
}
```

**Important patterns to follow:**
- Use `"user"` (with quotes) for the Better Auth user table reference
- All amounts stored as TEXT (strings) to avoid precision loss
- Timestamps use `datetime('now')` default
- Use nanoid for IDs (handled in CRUD layer)
- Index foreign keys and commonly-queried columns
  </action>
  <verify>
Run TypeScript compilation to ensure no type errors:
```bash
cd packages/server && npx tsc --noEmit
```
  </verify>
  <done>
- Four CREATE TABLE statements added to index.ts initializeDatabase()
- Four TypeScript interfaces added to types.ts
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CRUD modules and wire exports</name>
  <files>
    packages/server/src/db/reward-addresses.ts
    packages/server/src/db/campaigns.ts
    packages/server/src/db/reward-claims.ts
    packages/server/src/db/volume-snapshots.ts
    packages/server/src/db/index.ts
  </files>
  <action>
Create four new CRUD module files following the exact pattern from `facilitators.ts`. Each module must:
- Import nanoid, getDatabase, and relevant types
- Use .js extensions in imports (ES modules)
- Return null for UNIQUE constraint violations (not throw)
- Use prepared statements with positional parameters

**1. reward-addresses.ts:**
```typescript
import { nanoid } from 'nanoid';
import { getDatabase } from './index.js';
import type { RewardAddressRecord } from './types.js';

export function createRewardAddress(data: {
  user_id: string;
  chain_type: 'solana' | 'evm';
  address: string;
}): RewardAddressRecord | null {
  const db = getDatabase();
  const id = nanoid();

  // Normalize: lowercase for EVM, preserve case for Solana (base58)
  const normalizedAddress = data.chain_type === 'evm'
    ? data.address.toLowerCase()
    : data.address;

  try {
    const stmt = db.prepare(`
      INSERT INTO reward_addresses (id, user_id, chain_type, address)
      VALUES (?, ?, ?, ?)
    `);
    stmt.run(id, data.user_id, data.chain_type, normalizedAddress);
    return getRewardAddressById(id);
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes('UNIQUE constraint failed')) {
      return null;
    }
    throw error;
  }
}

export function getRewardAddressById(id: string): RewardAddressRecord | null {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM reward_addresses WHERE id = ?');
  return (stmt.get(id) as RewardAddressRecord) || null;
}

export function getRewardAddressesByUser(userId: string): RewardAddressRecord[] {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM reward_addresses WHERE user_id = ? ORDER BY created_at DESC');
  return stmt.all(userId) as RewardAddressRecord[];
}

export function getRewardAddressByAddress(address: string, chainType: 'solana' | 'evm'): RewardAddressRecord | null {
  const db = getDatabase();
  const normalizedAddress = chainType === 'evm' ? address.toLowerCase() : address;
  const stmt = db.prepare('SELECT * FROM reward_addresses WHERE address = ? AND chain_type = ?');
  return (stmt.get(normalizedAddress, chainType) as RewardAddressRecord) || null;
}

export function getVerifiedAddressesByUser(userId: string): RewardAddressRecord[] {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT * FROM reward_addresses
    WHERE user_id = ? AND verification_status = 'verified'
    ORDER BY created_at DESC
  `);
  return stmt.all(userId) as RewardAddressRecord[];
}

export function verifyRewardAddress(id: string): RewardAddressRecord | null {
  const db = getDatabase();
  const stmt = db.prepare(`
    UPDATE reward_addresses
    SET verification_status = 'verified', verified_at = datetime('now')
    WHERE id = ?
  `);
  const result = stmt.run(id);
  if (result.changes === 0) return null;
  return getRewardAddressById(id);
}

export function deleteRewardAddress(id: string): boolean {
  const db = getDatabase();
  const stmt = db.prepare('DELETE FROM reward_addresses WHERE id = ?');
  const result = stmt.run(id);
  return result.changes > 0;
}
```

**2. campaigns.ts:**
```typescript
import { nanoid } from 'nanoid';
import { getDatabase } from './index.js';
import type { CampaignRecord } from './types.js';

export function createCampaign(data: {
  name: string;
  pool_amount: string;
  threshold_amount: string;
  multiplier_facilitator?: number;
  starts_at: string;
  ends_at: string;
}): CampaignRecord {
  const db = getDatabase();
  const id = nanoid();

  const stmt = db.prepare(`
    INSERT INTO campaigns (id, name, pool_amount, threshold_amount, multiplier_facilitator, starts_at, ends_at)
    VALUES (?, ?, ?, ?, ?, ?, ?)
  `);
  stmt.run(
    id,
    data.name,
    data.pool_amount,
    data.threshold_amount,
    data.multiplier_facilitator ?? 2.0,
    data.starts_at,
    data.ends_at
  );
  return getCampaignById(id)!;
}

export function getCampaignById(id: string): CampaignRecord | null {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM campaigns WHERE id = ?');
  return (stmt.get(id) as CampaignRecord) || null;
}

export function getActiveCampaign(): CampaignRecord | null {
  const db = getDatabase();
  const stmt = db.prepare("SELECT * FROM campaigns WHERE status = 'active' LIMIT 1");
  return (stmt.get() as CampaignRecord) || null;
}

export function getAllCampaigns(): CampaignRecord[] {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM campaigns ORDER BY created_at DESC');
  return stmt.all() as CampaignRecord[];
}

export function updateCampaign(
  id: string,
  updates: Partial<{
    name: string;
    pool_amount: string;
    threshold_amount: string;
    multiplier_facilitator: number;
    starts_at: string;
    ends_at: string;
    status: 'draft' | 'active' | 'ended';
  }>
): CampaignRecord | null {
  const db = getDatabase();

  const fields: string[] = [];
  const values: (string | number)[] = [];

  if (updates.name !== undefined) {
    fields.push('name = ?');
    values.push(updates.name);
  }
  if (updates.pool_amount !== undefined) {
    fields.push('pool_amount = ?');
    values.push(updates.pool_amount);
  }
  if (updates.threshold_amount !== undefined) {
    fields.push('threshold_amount = ?');
    values.push(updates.threshold_amount);
  }
  if (updates.multiplier_facilitator !== undefined) {
    fields.push('multiplier_facilitator = ?');
    values.push(updates.multiplier_facilitator);
  }
  if (updates.starts_at !== undefined) {
    fields.push('starts_at = ?');
    values.push(updates.starts_at);
  }
  if (updates.ends_at !== undefined) {
    fields.push('ends_at = ?');
    values.push(updates.ends_at);
  }
  if (updates.status !== undefined) {
    fields.push('status = ?');
    values.push(updates.status);
  }

  if (fields.length === 0) {
    return getCampaignById(id);
  }

  fields.push("updated_at = datetime('now')");
  values.push(id);

  const stmt = db.prepare(`UPDATE campaigns SET ${fields.join(', ')} WHERE id = ?`);
  const result = stmt.run(...values);

  if (result.changes === 0) return null;
  return getCampaignById(id);
}

export function deleteCampaign(id: string): boolean {
  const db = getDatabase();
  const stmt = db.prepare('DELETE FROM campaigns WHERE id = ?');
  const result = stmt.run(id);
  return result.changes > 0;
}
```

**3. reward-claims.ts:**
```typescript
import { nanoid } from 'nanoid';
import { getDatabase } from './index.js';
import type { RewardClaimRecord } from './types.js';

export function createRewardClaim(data: {
  user_id: string;
  campaign_id: string;
  volume_amount: string;
  base_reward_amount: string;
  multiplier?: number;
  final_reward_amount: string;
  claim_wallet?: string;
}): RewardClaimRecord | null {
  const db = getDatabase();
  const id = nanoid();

  try {
    const stmt = db.prepare(`
      INSERT INTO reward_claims (id, user_id, campaign_id, volume_amount, base_reward_amount, multiplier, final_reward_amount, claim_wallet)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      id,
      data.user_id,
      data.campaign_id,
      data.volume_amount,
      data.base_reward_amount,
      data.multiplier ?? 1.0,
      data.final_reward_amount,
      data.claim_wallet || null
    );
    return getRewardClaimById(id);
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes('UNIQUE constraint failed')) {
      return null;
    }
    throw error;
  }
}

export function getRewardClaimById(id: string): RewardClaimRecord | null {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM reward_claims WHERE id = ?');
  return (stmt.get(id) as RewardClaimRecord) || null;
}

export function getRewardClaimsByUser(userId: string): RewardClaimRecord[] {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM reward_claims WHERE user_id = ? ORDER BY created_at DESC');
  return stmt.all(userId) as RewardClaimRecord[];
}

export function getRewardClaimsByCampaign(campaignId: string): RewardClaimRecord[] {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM reward_claims WHERE campaign_id = ? ORDER BY created_at DESC');
  return stmt.all(campaignId) as RewardClaimRecord[];
}

export function getRewardClaimByUserAndCampaign(userId: string, campaignId: string): RewardClaimRecord | null {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM reward_claims WHERE user_id = ? AND campaign_id = ?');
  return (stmt.get(userId, campaignId) as RewardClaimRecord) || null;
}

export function updateRewardClaim(
  id: string,
  updates: Partial<{
    status: 'pending' | 'processing' | 'completed' | 'failed';
    claim_wallet: string;
    tx_signature: string;
    claimed_at: string;
  }>
): RewardClaimRecord | null {
  const db = getDatabase();

  const fields: string[] = [];
  const values: (string | null)[] = [];

  if (updates.status !== undefined) {
    fields.push('status = ?');
    values.push(updates.status);
  }
  if (updates.claim_wallet !== undefined) {
    fields.push('claim_wallet = ?');
    values.push(updates.claim_wallet);
  }
  if (updates.tx_signature !== undefined) {
    fields.push('tx_signature = ?');
    values.push(updates.tx_signature);
  }
  if (updates.claimed_at !== undefined) {
    fields.push('claimed_at = ?');
    values.push(updates.claimed_at);
  }

  if (fields.length === 0) {
    return getRewardClaimById(id);
  }

  values.push(id);

  const stmt = db.prepare(`UPDATE reward_claims SET ${fields.join(', ')} WHERE id = ?`);
  const result = stmt.run(...values);

  if (result.changes === 0) return null;
  return getRewardClaimById(id);
}
```

**4. volume-snapshots.ts:**
```typescript
import { nanoid } from 'nanoid';
import { getDatabase } from './index.js';
import type { VolumeSnapshotRecord } from './types.js';

export function createVolumeSnapshot(data: {
  reward_address_id: string;
  campaign_id: string;
  snapshot_date: string;
  volume: string;
  unique_payers?: number;
}): VolumeSnapshotRecord | null {
  const db = getDatabase();
  const id = nanoid();

  try {
    const stmt = db.prepare(`
      INSERT INTO volume_snapshots (id, reward_address_id, campaign_id, snapshot_date, volume, unique_payers)
      VALUES (?, ?, ?, ?, ?, ?)
    `);
    stmt.run(
      id,
      data.reward_address_id,
      data.campaign_id,
      data.snapshot_date,
      data.volume,
      data.unique_payers ?? 0
    );
    return getVolumeSnapshotById(id);
  } catch (error: unknown) {
    if (error instanceof Error && error.message.includes('UNIQUE constraint failed')) {
      return null;
    }
    throw error;
  }
}

export function getVolumeSnapshotById(id: string): VolumeSnapshotRecord | null {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM volume_snapshots WHERE id = ?');
  return (stmt.get(id) as VolumeSnapshotRecord) || null;
}

export function getVolumeSnapshotsByAddress(rewardAddressId: string): VolumeSnapshotRecord[] {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM volume_snapshots WHERE reward_address_id = ? ORDER BY snapshot_date DESC');
  return stmt.all(rewardAddressId) as VolumeSnapshotRecord[];
}

export function getVolumeSnapshotsByCampaign(campaignId: string): VolumeSnapshotRecord[] {
  const db = getDatabase();
  const stmt = db.prepare('SELECT * FROM volume_snapshots WHERE campaign_id = ? ORDER BY snapshot_date DESC');
  return stmt.all(campaignId) as VolumeSnapshotRecord[];
}

export function getVolumeSnapshotByAddressAndDate(
  rewardAddressId: string,
  campaignId: string,
  snapshotDate: string
): VolumeSnapshotRecord | null {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT * FROM volume_snapshots
    WHERE reward_address_id = ? AND campaign_id = ? AND snapshot_date = ?
  `);
  return (stmt.get(rewardAddressId, campaignId, snapshotDate) as VolumeSnapshotRecord) || null;
}

export function upsertVolumeSnapshot(data: {
  reward_address_id: string;
  campaign_id: string;
  snapshot_date: string;
  volume: string;
  unique_payers?: number;
}): VolumeSnapshotRecord {
  const db = getDatabase();

  // Check if exists
  const existing = getVolumeSnapshotByAddressAndDate(
    data.reward_address_id,
    data.campaign_id,
    data.snapshot_date
  );

  if (existing) {
    // Update existing
    const stmt = db.prepare(`
      UPDATE volume_snapshots
      SET volume = ?, unique_payers = ?
      WHERE id = ?
    `);
    stmt.run(data.volume, data.unique_payers ?? 0, existing.id);
    return getVolumeSnapshotById(existing.id)!;
  } else {
    // Create new
    return createVolumeSnapshot(data)!;
  }
}

export function getUserVolumeForCampaign(userId: string, campaignId: string): {
  total_volume: string;
  unique_payers: number;
} {
  const db = getDatabase();

  const stmt = db.prepare(`
    SELECT
      COALESCE(SUM(CAST(vs.volume AS INTEGER)), 0) as total_volume,
      COALESCE(SUM(vs.unique_payers), 0) as unique_payers
    FROM volume_snapshots vs
    JOIN reward_addresses ra ON vs.reward_address_id = ra.id
    WHERE ra.user_id = ? AND vs.campaign_id = ?
  `);

  const result = stmt.get(userId, campaignId) as {
    total_volume: number;
    unique_payers: number;
  };

  return {
    total_volume: String(result.total_volume),
    unique_payers: result.unique_payers,
  };
}
```

**Finally, add exports to index.ts** (at the end of the file, after the existing exports):

```typescript
export * from './reward-addresses.js';
export * from './campaigns.js';
export * from './reward-claims.js';
export * from './volume-snapshots.js';
```
  </action>
  <verify>
1. TypeScript compilation:
```bash
cd packages/server && npx tsc --noEmit
```

2. Quick smoke test - start the server to trigger database initialization:
```bash
cd packages/server && npm run dev
```
Look for the "Database initialized" message without errors. Then Ctrl+C to stop.
  </verify>
  <done>
- Four CRUD module files created following facilitators.ts pattern
- All modules exported from index.ts
- TypeScript compiles without errors
- Database initializes without errors (tables created)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **TypeScript Check:**
```bash
cd packages/server && npx tsc --noEmit
```
Should pass with no errors.

2. **Database Initialization:**
```bash
cd packages/server && npm run dev
```
Should see "Database initialized at..." without any table creation errors.

3. **Schema Verification:**
```bash
sqlite3 ./data/openfacilitator.db ".tables"
```
Should show: reward_addresses, campaigns, reward_claims, volume_snapshots (among others)

4. **Import Verification:**
```bash
cd packages/server && node -e "import('./dist/db/index.js').then(m => console.log(Object.keys(m).filter(k => k.includes('Reward') || k.includes('Campaign') || k.includes('Volume'))))"
```
Should list the exported functions from the new modules.
</verification>

<success_criteria>
- [ ] Four reward tables exist in SQLite database (reward_addresses, campaigns, reward_claims, volume_snapshots)
- [ ] TypeScript interfaces defined for all four record types
- [ ] CRUD modules created with standard patterns (create, get, update, delete)
- [ ] All modules exported from db/index.ts
- [ ] TypeScript compiles without errors
- [ ] Database initialization runs without errors
- [ ] Schema supports required relationships (user -> addresses, user -> claims, campaign -> claims)
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>
